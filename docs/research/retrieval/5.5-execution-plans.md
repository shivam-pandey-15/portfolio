# Chapter 5.5: Execution Plans - Research Document

## Overview

**Execution Plans** describe how a search engine translates a high-level query into low-level operations against the index. This chapter covers the internal machinery that turns "search for laptops under $500" into actual disk reads, iterator operations, and score calculations.

---

## 1. The Query → Weight → Scorer Pipeline

This is the fundamental architecture of Lucene query execution. Understanding this three-layer abstraction is essential.

### 1.1 Query Object
- **What it is**: The user-facing representation of a search (TermQuery, BooleanQuery, PhraseQuery, etc.)
- **Key property**: Stateless and reusable across searches
- **Role**: Defines WHAT to search for, not HOW

### 1.2 Weight Object
- **What it is**: IndexSearcher-dependent but segment-independent state
- **Created by**: `Query.createWeight(IndexSearcher, ScoreMode, float boost)`
- **Responsibilities**:
  - Computes query-level statistics (IDF values, boosts)
  - Acts as factory for Scorers (one per segment)
  - Holds the "rewritten" form of the query
- **Key insight**: IDF is computed ONCE per query, not per segment

### 1.3 Scorer Object
- **What it is**: Segment-specific iterator + score calculator
- **Created by**: `Weight.scorer(LeafReaderContext)`
- **Returns**: `DocIdSetIterator` for document iteration
- **Responsibilities**:
  - Iterate matching documents within ONE segment
  - Calculate TF and length normalization per document
  - Return documents in increasing docID order

### 1.4 BulkScorer (Optional Optimization)
- **What it is**: Scores ranges of documents at once instead of one-by-one
- **When used**: For queries that can identify matching document ranges efficiently
- **Key method**: `BulkScorer.score(LeafCollector, Bits, int min, int max)`
- **Fallback**: Default wraps a regular Scorer

```
┌─────────────────────────────────────────────────────────────────┐
│                         Query                                    │
│                    (stateless, reusable)                        │
└──────────────────────────┬──────────────────────────────────────┘
                           │ createWeight()
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                         Weight                                   │
│              (IndexSearcher-level: IDF, boosts)                 │
└──────────────────────────┬──────────────────────────────────────┘
                           │ scorer() × N segments
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│              Scorer₁    Scorer₂    ...    Scorer_N              │
│           (per-segment: TF, norms, iteration)                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. Segment Iteration

### 2.1 Why Segments Matter
- Lucene index = collection of immutable segments
- Each segment is searched independently
- Results merged at the end
- Enables concurrent execution (parallel segment search)

### 2.2 Execution Flow
1. **Prepare**: Query → Weight (compute IDF, rewrite)
2. **For each segment**:
   - Create Scorer from Weight
   - Iterate matching documents
   - Collect results into priority queue
3. **Merge**: Combine segment results, return top-K

### 2.3 LeafReaderContext
- Represents a single segment
- Contains:
  - `docBase`: Starting docID for this segment
  - `reader()`: Access to segment data (postings, norms, docValues)
- Essential for mapping local docIDs to global docIDs

---

## 3. DocIdSetIterator (DISI)

The heart of Lucene's query execution. All matching/filtering reduces to iterating document IDs.

### 3.1 Core Methods
```java
int nextDoc()      // Advance to next matching doc
int advance(int)   // Skip to target docID or beyond
int docID()        // Current document ID
long cost()        // Estimated number of matching docs (for optimization)
```

### 3.2 Key DISI Implementations

| Class | Purpose | Strategy |
|-------|---------|----------|
| `TermScorer` | Single term matches | Iterate posting list |
| `ConjunctionDISI` | AND queries | Intersection via leap-frog |
| `DisjunctionDISI` | OR queries | Union via priority queue |
| `ReqExclScorer` | MUST_NOT handling | Skip excluded docs |
| `BlockMaxDISI` | Early termination | Skip low-scoring blocks |
| `ImpactsDISI` | WAND optimization | Impact-aware skipping |

### 3.3 The Leap-Frog Algorithm (Conjunctions)
For query `A AND B AND C`:
1. Find current minimum docID among A, B, C
2. Advance all others to that docID
3. If all align → match! Else repeat from step 1

**Optimization**: Sort sub-queries by cost (cheapest first) to minimize advance() calls.

### 3.4 Priority Queue Algorithm (Disjunctions)
For query `A OR B OR C`:
1. All iterators in min-heap by current docID
2. Pop iterator with smallest docID
3. Collect all iterators at same docID → compute combined score
4. Advance popped iterators, reinsert into heap
5. Repeat until exhausted

---

## 4. TwoPhaseIterator

An optimization for expensive match conditions (e.g., phrase queries, span queries).

### 4.1 Concept
- **Phase 1 (Approximation)**: Fast check - "might match"
- **Phase 2 (Confirmation)**: Expensive check - "definitely matches"

### 4.2 Why It Matters
For phrase query "quick brown fox":
- **Phase 1**: Doc contains all three terms? (cheap - posting list intersection)
- **Phase 2**: Terms appear consecutively? (expensive - position check)

### 4.3 Implementation
```java
TwoPhaseIterator {
    DocIdSetIterator approximation()  // Fast DISI
    boolean matches()                  // Expensive confirmation
    float matchCost()                  // Hint for optimization
}
```

Scorers can return TwoPhaseIterator via `Scorer.twoPhaseIterator()`.

---

## 5. Query Rewriting

Transformation of abstract/syntactic queries into optimized, executable forms.

### 5.1 Why Rewrite?
- Expand wildcards/prefixes to actual terms
- Simplify Boolean logic
- Enable accurate cost estimation
- Apply optimizations (constant scoring, etc.)

### 5.2 Examples

| Original Query | Rewritten Form |
|----------------|----------------|
| `title:lap*` | `BooleanQuery(OR: laptop, lap, lapel, ...)` |
| `+A +B -C` where C matches 0 docs | `+A +B` |
| `BooleanQuery(MUST: A)` | `A` (unwrap single clause) |
| `ConstantScoreQuery(q)` | Removes scoring overhead |

### 5.3 Multi-pass Rewriting
- `Query.rewrite(IndexReader)` may be called multiple times
- Returns `this` when no more rewriting possible
- Must be idempotent: `q.rewrite().rewrite() == q.rewrite()`

### 5.4 Cost Estimation After Rewriting
- Query cost = estimated matching documents
- Used to optimize execution order
- Cheaper queries executed first in conjunctions

---

## 6. Boolean Query Execution

### 6.1 Clause Types
| Occur | Meaning | Affects Score? | Caching? |
|-------|---------|----------------|----------|
| MUST | Required | Yes | No |
| FILTER | Required | No | Yes |
| SHOULD | Optional (boosts score) | Yes | No |
| MUST_NOT | Excluded | No | Yes |

### 6.2 MinShouldMatch
- Controls how many SHOULD clauses must match
- `minimumShouldMatch = 2` means at least 2 of N SHOULD clauses
- Can be percentage: "75%" = floor(0.75 × numShouldClauses)

### 6.3 Scorer Selection
Lucene dynamically chooses scorers based on query structure:
- **ConjunctionScorer**: All MUST clauses
- **ReqOptSumScorer**: MUST + SHOULD (sum scores)
- **ReqExclScorer**: MUST - MUST_NOT 
- **DisjunctionSumScorer**: Multiple SHOULD with minShouldMatch
- **BooleanScorer2**: Complex combinations

### 6.4 Execution Order Optimization
Lucene reorders query clauses by cost:
1. Estimate cost of each clause (from posting list length)
2. Execute cheapest clauses first
3. Use results to skip work in expensive clauses

Example: `color:blue AND category:electronics`
- If "blue" matches 10K docs and "electronics" matches 1M docs
- Execute "blue" first, then check "electronics" only for those 10K

---

## 7. Profile API (Elasticsearch)

Understanding query execution via profiling.

### 7.1 Enabling Profiles
```json
{
  "profile": true,
  "query": { ... }
}
```

### 7.2 Profile Output Structure
```json
{
  "profile": {
    "shards": [{
      "id": "[node][index][shard]",
      "searches": [{
        "query": [{
          "type": "BooleanQuery",
          "description": "+title:laptop +category:electronics",
          "time_in_nanos": 123456,
          "breakdown": {
            "create_weight": 1000,
            "build_scorer": 5000,
            "next_doc": 100000,
            "advance": 10000,
            "score": 5000,
            "match": 2000
          },
          "children": [...]
        }],
        "rewrite_time": 5000,
        "collector": [{
          "name": "SimpleTopScoreDocCollector",
          "reason": "search_top_hits",
          "time_in_nanos": 50000
        }]
      }]
    }]
  }
}
```

### 7.3 Key Breakdown Metrics

| Metric | What It Measures |
|--------|------------------|
| `create_weight` | Time to create Weight (IDF calculation) |
| `build_scorer` | Time to create Scorer for segment |
| `next_doc` | Time iterating to next matching doc |
| `advance` | Time skipping to target docID |
| `score` | Time computing relevance scores |
| `match` | Time in TwoPhaseIterator.matches() |
| `set_min_competitive_score` | Time updating score threshold |

### 7.4 Common Patterns
- **High `next_doc`**: Expensive iteration (large posting lists)
- **High `build_scorer`**: Complex query structure
- **High `match`**: Expensive TwoPhaseIterator (phrase queries)
- **High `score`**: Complex similarity (scripts, function_score)

---

## 8. Distributed Execution (Elasticsearch)

### 8.1 Query-Then-Fetch Model
**Phase 1: Query**
1. Coordinator routes to relevant shards
2. Each shard executes query locally
3. Returns top-K docIDs + scores (not full documents)

**Phase 2: Fetch**
1. Coordinator merges results globally
2. Requests full documents for final top-K
3. Returns enriched results to client

### 8.2 Why Two Phases?
- Avoids transferring full documents that won't make final cut
- Reduces network bandwidth
- Enables efficient distributed top-K

### 8.3 Routing Optimizations
- **Custom routing**: Send query to single shard (if routing key known)
- **Preference**: Sticky routing to same replica (cache benefits)
- **Adaptive replica selection**: Route to fastest replica

---

## 9. Cost-Based Optimization

### 9.1 Query Cost Model
```java
long cost = query.createWeight(...).scorer(...).iterator().cost();
```
- Returns estimated number of matching documents
- Used to order clause execution
- Lower cost = executed first

### 9.2 Optimization Strategies
1. **Clause Reordering**: Cheapest first in conjunctions
2. **Early Termination**: Stop when top-K is full and threshold met
3. **Block Skipping**: Skip document blocks that can't beat threshold
4. **Cache Reuse**: Filter results cached per segment

### 9.3 When Cost Estimation Fails
- Range queries on unsorted fields
- Script queries (unknown selectivity)
- Cross-field queries
- Very dynamic data

---

## 10. Practical Examples

### 10.1 Simple Term Query Execution
Query: `title:laptop`
1. **Rewrite**: Already primitive → no change
2. **Weight**: Compute IDF from docFreq
3. **Scorer**: Create TermScorer from posting list
4. **Iterate**: Read (docID, TF) pairs, compute BM25

### 10.2 Boolean AND Execution
Query: `+title:laptop +price:[0 TO 500]`
1. **Rewrite**: term + range → primitive
2. **Weight**: Create BooleanWeight with two sub-weights
3. **Cost estimation**: term=10K, range=50K
4. **Scorer**: ConjunctionDISI(termScorer, rangeScorer)
5. **Iterate**: Leap-frog on term (cheaper), check range

### 10.3 Phrase Query Execution
Query: `"quick brown fox"`
1. **Rewrite**: Already primitive
2. **Weight**: Get posting lists for all terms
3. **Scorer**: PhraseScorer with TwoPhaseIterator
4. **Phase 1**: Documents containing all terms
5. **Phase 2**: Check positions for adjacency

---

## 11. Key Takeaways

1. **Query → Weight → Scorer**: Three-layer abstraction separating what from how
2. **Segments are independent**: Enables parallelism, requires merge
3. **DISI is everything**: All matching reduces to document iteration
4. **Cost drives optimization**: Cheaper clauses first
5. **TwoPhaseIterator**: Cheap approximation + expensive confirmation
6. **Rewriting matters**: Transforms abstract to executable
7. **Profile API**: Essential for debugging slow queries
8. **Query-Then-Fetch**: Two-phase distributed execution

---

## 12. Topics for Chapter Implementation

### High Priority (Core Content)
- [ ] Query → Weight → Scorer pipeline visualization
- [ ] DISI iteration animation (leap-frog, priority queue)
- [ ] Boolean query clause execution order
- [ ] Profile API interpretation guide
- [ ] Query rewriting examples

### Medium Priority (Depth)
- [ ] TwoPhaseIterator explained
- [ ] Cost estimation mechanics
- [ ] Distributed query execution flow
- [ ] Common slow query patterns

### Optional (Advanced)
- [ ] BulkScorer optimization
- [ ] ImpactsDISI and WAND integration
- [ ] Concurrent segment execution
- [ ] Custom similarity effects on scoring path
