# 3.2 Types of Data in Search

Search engines don't operate on a single data type. Understanding the different data categories and their characteristics is essential for building scalable systems.

---

## 1. The Data Taxonomy

### A. Text Data (Unstructured)
**Definition**: Human-readable content with no fixed schema.

**Examples:**
```json
{
  "title": "Apple MacBook Pro 16-inch M3 Max",
  "description": "The most powerful MacBook ever. Features the blazing-fast M3 Max chip with up to 128GB unified memory.",
  "reviews": [
    "Amazing laptop, best I've ever used!",
    "A bit expensive but worth every penny"
  ]
}
```

**Characteristics:**
| Property | Value |
|----------|-------|
| Entropy | High (unpredictable content) |
| Analysis Required | Yes (tokenization, stemming) |
| Query Type | Full-text search, fuzzy matching |
| Storage Cost | High (inverted index overhead) |

**Real-World Scale:**
- Amazon: Average product description = 500 words
- With 500M products = 250 billion words to index
- After tokenization: ~100 billion unique terms

---

### B. Structured Data (Exact Values)
**Definition**: Data with strict types and known value ranges.

**Examples:**
```json
{
  "price": 2499.99,
  "stock_count": 1523,
  "release_date": "2024-01-15",
  "rating": 4.7,
  "location": {
    "lat": 37.7749,
    "lon": -122.4194
  }
}
```

**Characteristics:**
| Property | Value |
|----------|-------|
| Entropy | Low (bounded values) |
| Analysis Required | No (stored exactly) |
| Query Type | Range, exact match, geo |
| Storage Cost | Low (BKD trees, efficient compression) |

**Real-World Example: Price Filtering**
```json
// User query: "Laptops between $500 and $1500"

// Elasticsearch query
{
  "query": {
    "bool": {
      "must": { "match": { "category": "laptops" } },
      "filter": {
        "range": { "price": { "gte": 500, "lte": 1500 } }
      }
    }
  }
}
```

**Performance:**
- Filtering 100M products by price range: **5ms**
- Without BKD tree (string comparison): **500ms**
- 100x faster with proper typing

---

### C. Semi-Structured Data (Flexible Schema)
**Definition**: JSON objects with varying fields per document.

**Example: Product Specifications**
```json
// Laptop
{
  "specs": {
    "screen_size": "16 inch",
    "ram": "32GB",
    "storage": "1TB SSD",
    "processor": "M3 Max"
  }
}

// T-Shirt
{
  "specs": {
    "size": "Large",
    "color": "Navy Blue",
    "material": "100% Cotton",
    "care": "Machine Washable"
  }
}
```

**The Challenge: Dynamic Mapping**
```python
# Without control, Elasticsearch creates fields dynamically
# Result: 10,000+ unique field names across product types
# Mapping explosion = slow cluster, high memory

# Solution: Flattened type (Elasticsearch 7.3+)
{
  "mappings": {
    "properties": {
      "specs": {
        "type": "flattened"  # All specs stored as key-value pairs
      }
    }
  }
}
```

**Trade-off:**
| Approach | Pros | Cons |
|----------|------|------|
| Dynamic mapping | Full query power | Mapping explosion |
| Flattened | Controlled size | No range queries on values |
| Nested object | Structured queries | Update cost |

---

### D. Graph Data (Relationships)
**Definition**: Connections between entities.

**Example: E-commerce Graph**
```
User --[purchased]--> Product
Product --[belongs_to]--> Category
Product --[made_by]--> Brand
Brand --[headquartered_in]--> Country
User --[follows]--> Brand
```

**The Flattening Problem:**
```json
// Normalized (Graph DB)
// Product
{ "id": "prod_1", "brand_id": "brand_nike" }
// Brand
{ "id": "brand_nike", "name": "Nike", "country": "USA" }

// Denormalized (Search Index)
{
  "id": "prod_1",
  "brand": {
    "id": "brand_nike",
    "name": "Nike",
    "country": "USA"
  }
}
```

**Real-World Case Study: Flipkart Category Graph**
```
Category hierarchy depth: 5 levels
Total categories: 15,000
Products per leaf category: 1,000 - 100,000

Challenge: User searches "mobile phones"
- Must match products in:
  - Electronics > Mobiles > Smartphones
  - Electronics > Mobiles > Feature Phones
  - Electronics > Mobiles > Accessories > Cases
  
Solution: Index all ancestor categories on product
{
  "product": "iPhone 15",
  "category_path": ["Electronics", "Mobiles", "Smartphones"],
  "category_ids": ["cat_1", "cat_1_1", "cat_1_1_1"]
}
```

---

### E. Behavioral Data (Signals)
**Definition**: User interaction logs used for ranking.

**Example: Click Stream**
```json
{
  "event": "click",
  "timestamp": "2024-01-15T10:30:00Z",
  "user_id": "user_12345",
  "session_id": "sess_abc",
  "query": "running shoes",
  "product_id": "prod_nike_123",
  "position": 3,
  "dwell_time_ms": 45000
}
```

**Scale Reality:**
| Metric | E-commerce (1M DAU) | Google Scale |
|--------|---------------------|--------------|
| Clicks/day | 50M | 8.5B |
| Events/second | 600 | 100,000 |
| Storage/day | 50GB | 10TB |
| Retention | 90 days | Years |

**Aggregation Pipeline:**
```python
# Raw events are useless for ranking
# Must aggregate into features

# Flink streaming job
def aggregate_signals(events_stream):
    return events_stream \
        .key_by(lambda e: e["product_id"]) \
        .window(TumblingWindow.of(Time.minutes(15))) \
        .aggregate(
            click_count=count(),
            avg_dwell_time=avg("dwell_time_ms"),
            ctr=divide(count("click"), count("impression"))
        )

# Output (stored in Feature Store)
{
  "product_id": "prod_nike_123",
  "click_count_15m": 47,
  "avg_dwell_time": 32000,
  "ctr_15m": 0.12
}
```

---

## 2. The Three Data Views

### View 1: Source of Truth (OLTP)
**Purpose**: Reliability, ACID compliance
**Technology**: PostgreSQL, MySQL, DynamoDB
**Schema**: Normalized (3NF)

```sql
-- Products table
CREATE TABLE products (
    id UUID PRIMARY KEY,
    title VARCHAR(255),
    brand_id UUID REFERENCES brands(id),
    category_id UUID REFERENCES categories(id),
    price DECIMAL(10,2)
);

-- Brands table
CREATE TABLE brands (
    id UUID PRIMARY KEY,
    name VARCHAR(100),
    country VARCHAR(50)
);
```

### View 2: Search Index (OLAP-ish)
**Purpose**: Fast retrieval
**Technology**: Elasticsearch, Solr, Vespa
**Schema**: Denormalized, Flattened

```json
{
  "id": "prod_123",
  "title": "Nike Air Max 90",
  "brand_name": "Nike",           // Denormalized from brands table
  "brand_country": "USA",         // Denormalized
  "category_name": "Running Shoes",
  "category_path": ["Sports", "Footwear", "Running Shoes"],
  "price": 149.99,
  "click_count_7d": 1500,         // From behavioral aggregate
  "avg_rating": 4.5               // From reviews aggregate
}
```

### View 3: Feature Store (ML Signals)
**Purpose**: Fast feature lookup for ranking
**Technology**: Redis, Cassandra, Feast

```python
# Feature Store schema
class ProductFeatures(FeatureView):
    entities = ["product_id"]
    features = [
        Feature("click_count_7d", Int64),
        Feature("purchase_rate_30d", Float32),
        Feature("return_rate", Float32),
        Feature("embedding", Float32Array[768]),
    ]
    ttl = timedelta(hours=1)
```

---

## 3. Data Flow Architecture

```
┌─────────────────┐
│   Source DB     │ ── CDC (Debezium) ──┐
│   (PostgreSQL)  │                      │
└─────────────────┘                      ▼
                                    ┌─────────┐
┌─────────────────┐                 │  Kafka  │
│  Click Stream   │ ── Events ──────►│         │
│   (Frontend)    │                 └────┬────┘
└─────────────────┘                      │
                                         ▼
                           ┌─────────────────────────┐
                           │    Stream Processor     │
                           │  (Flink / Spark)        │
                           └────────────┬────────────┘
                                        │
                    ┌───────────────────┼───────────────────┐
                    ▼                   ▼                   ▼
            ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
            │ Search Index  │   │ Feature Store │   │   Data Lake   │
            │ (Elasticsearch)│   │   (Redis)     │   │   (S3/GCS)    │
            └───────────────┘   └───────────────┘   └───────────────┘
```

**Key Principles:**
1. **Never dual-write**: Don't write to DB and Search simultaneously
2. **Single source of truth**: DB is authoritative, Search is a view
3. **Event-driven**: Changes flow through Kafka, not direct API calls
4. **Rebuildable**: Search index can be recreated from DB + Feature Store
