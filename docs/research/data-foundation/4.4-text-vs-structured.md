# 3.4 Text vs Structured Data

Understanding when to use text analysis vs exact matching is fundamental to search performance and correctness.

---

## 1. The Fundamental Difference

### Text Fields: For Human Language
```json
{
  "title": "Apple MacBook Pro 16-inch with M3 Max Chip"
}

// After analysis (standard analyzer):
["apple", "macbook", "pro", "16", "inch", "with", "m3", "max", "chip"]

// User searches: "macbook m3"
// Matches! Because tokens "macbook" and "m3" are present
```

### Structured Fields: For Machine Logic
```json
{
  "brand": "Apple",
  "price": 2499.99,
  "release_date": "2024-01-15"
}

// No analysis - stored exactly as provided

// Query: brand = "Apple"  → Exact match required
// Query: brand = "apple"  → NO MATCH (case sensitive)
// Query: price > 2000     → Range query on numeric
```

---

## 2. Internal Data Structures

### Inverted Index (Text)

**How it works:**
```
Original Documents:
Doc1: "The quick brown fox"
Doc2: "The lazy brown dog"
Doc3: "Quick foxes are quick"

Inverted Index:
Term      → Document IDs
─────────────────────────
"brown"   → [1, 2]
"dog"     → [2]
"fox"     → [1]
"foxes"   → [3]
"lazy"    → [2]
"quick"   → [1, 3, 3]  // Note: Doc3 has it twice
"the"     → [1, 2]
```

**Space Complexity:**
```
1 billion documents
Average 100 unique terms per doc
Total terms: 100B entries

With compression (Roaring Bitmap):
Storage: ~50GB for posting lists
```

### BKD Tree (Numeric/Geo)

**How it works:**
```
Points in 2D space (price, rating):

        ┌───────────────────────┐
        │    (2499, 4.8)        │
        │         ●             │
        │                       │
        │  (999, 4.2)    (1499, 4.5)
        │      ●             ●  │
        │                       │
        │ (599, 3.9)            │
        │     ●                 │
        └───────────────────────┘

BKD Tree splits space recursively:
                    [All Points]
                   /            \
           [price < 1000]    [price >= 1000]
              /    \            /        \
        [rating<4]  [>=4]  [rating<4.5] [>=4.5]
```

**Query Efficiency:**
```
Range: price BETWEEN 500 AND 1500

BKD traversal: Visit only matching subtrees
Complexity: O(log N) + O(K) where K = matching docs

Example:
- 100M products
- Price filter: 10ms
- String comparison: 2000ms (200x slower)
```

---

## 3. Common Mistakes (With Code)

### Mistake 1: ID as Text Field

**The Setup:**
```json
// BAD: Using text type for SKU
{
  "mappings": {
    "properties": {
      "sku": { "type": "text" }
    }
  }
}

// Document
{ "sku": "ABC-123-XYZ" }
```

**The Problem:**
```json
// Standard analyzer tokenizes it:
["abc", "123", "xyz"]

// User searches for exact SKU
{ "match": { "sku": "ABC-123-XYZ" } }

// Also matches!
{ "sku": "ABC-999-ZZZ" }  // Shares "abc" token
{ "sku": "XYZ-456-ABC" }  // Shares "abc" and "xyz" tokens
```

**The Fix:**
```json
{
  "mappings": {
    "properties": {
      "sku": { 
        "type": "keyword",  // Exact match only
        "ignore_above": 256
      }
    }
  }
}
```

---

### Mistake 2: Numeric as String

**The Setup:**
```json
// Data ingested with wrong types
{ "price": "99.99" }   // String!
{ "price": "9.99" }    // String!
{ "price": "1099.00" } // String!
```

**The Problem:**
```json
// Sort by price ascending
{ "sort": [{ "price": "asc" }] }

// String sort result (lexicographic):
1. "1099.00"  // '1' < '9'
2. "9.99"     // '9' < '9' (actually equal, but '.' < '9')
3. "99.99"

// Expected numeric sort:
1. "9.99"
2. "99.99"
3. "1099.00"
```

**The Fix:**
```python
# Ingestion validation
def validate_price(doc):
    price = doc.get("price")
    if isinstance(price, str):
        try:
            doc["price"] = float(price.replace(",", "").replace("$", ""))
        except ValueError:
            raise ValidationError(f"Invalid price: {price}")
    return doc
```

---

### Mistake 3: Brand in Text Field

**The Setup:**
```json
{
  "mappings": {
    "properties": {
      "brand": { "type": "text" }  // For "searchability"
    }
  }
}

// Documents
{ "brand": "Nike" }
{ "brand": "Nike Air" }
{ "brand": "Nike Inc." }
```

**The Problem:**
```json
// Aggregation for brand facets
{
  "aggs": {
    "brands": {
      "terms": { "field": "brand" }
    }
  }
}

// Result (on text field):
{
  "buckets": [
    { "key": "nike", "count": 3 },
    { "key": "air", "count": 1 },
    { "key": "inc", "count": 1 }
  ]
}
// Completely useless! Tokenized into separate words.
```

**The Fix: Multi-field Mapping**
```json
{
  "mappings": {
    "properties": {
      "brand": {
        "type": "text",          // For full-text search
        "fields": {
          "keyword": {
            "type": "keyword",   // For aggregations/sorting
            "ignore_above": 256
          }
        }
      }
    }
  }
}

// Search uses: brand
// Aggregation uses: brand.keyword
```

---

### Mistake 4: High Cardinality Aggregations

**The Setup:**
```json
// 100M users, each with unique user_id
{
  "aggs": {
    "unique_users": {
      "terms": { 
        "field": "user_id.keyword",
        "size": 10
      }
    }
  }
}
```

**The Problem:**
```
Global Ordinals build process:
- 100M unique values
- Each needs 8 bytes for ordinal mapping
- Memory: 100M × 8 bytes = 800MB

First aggregation query:
- Builds global ordinals: 30 seconds
- Heap pressure: Can trigger GC pause

Subsequent queries:
- Uses cached ordinals: 50ms
- But cache invalidated on any update!
```

**The Fix:**
```json
{
  "aggs": {
    "unique_users": {
      "terms": {
        "field": "user_id.keyword",
        "size": 10,
        "execution_hint": "map"  // Avoid global ordinals
      }
    }
  }
}

// Or use composite aggregation for pagination
{
  "aggs": {
    "users_page": {
      "composite": {
        "size": 100,
        "sources": [
          { "user": { "terms": { "field": "user_id.keyword" } } }
        ]
      }
    }
  }
}
```

---

## 4. Performance Benchmarks

### Query Type Comparison (1M documents)

| Query Type | Field Type | Time | Notes |
|------------|------------|------|-------|
| Exact match | keyword | 2ms | Hash lookup |
| Exact match | text (analyzed) | 5ms | Token lookup |
| Prefix | keyword | 8ms | FST traversal |
| Prefix | text | 15ms | Multiple token matches |
| Range (numeric) | long | 3ms | BKD tree |
| Range (string) | keyword | 50ms | Full scan |
| Regex | keyword | 200ms | Pattern matching |
| Wildcard | text | 500ms | Expensive! |

### Storage Comparison (1M documents)

| Data | Type | Storage | Index Speed |
|------|------|---------|-------------|
| UUIDs | keyword | 45MB | 50K/sec |
| UUIDs | text | 180MB | 12K/sec |
| Prices | long | 8MB | 100K/sec |
| Prices | text | 25MB | 30K/sec |
| Dates | date | 8MB | 100K/sec |
| Dates | text | 40MB | 25K/sec |

---

## 5. Decision Matrix

```
┌────────────────────────────────────────────────────────────┐
│                    TEXT vs STRUCTURED                       │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  Use TEXT (analyzed) when:                                  │
│  ✓ Human language content (titles, descriptions)           │
│  ✓ Fuzzy matching needed                                   │
│  ✓ Stemming/synonyms required                              │
│  ✓ Relevance scoring matters                               │
│                                                             │
│  Use KEYWORD (exact) when:                                  │
│  ✓ IDs, SKUs, codes                                        │
│  ✓ Enum values (status, category)                          │
│  ✓ Aggregations/facets needed                              │
│  ✓ Sorting required                                        │
│  ✓ Exact matching only                                     │
│                                                             │
│  Use NUMERIC (long/double) when:                            │
│  ✓ Range queries (prices, quantities)                      │
│  ✓ Mathematical operations                                 │
│  ✓ Numeric sorting                                         │
│                                                             │
│  Use DATE when:                                             │
│  ✓ Time-based filtering                                    │
│  ✓ Date math (now-7d)                                      │
│  ✓ Time-series data                                        │
│                                                             │
│  Use GEO_POINT when:                                        │
│  ✓ Location search (within X km)                           │
│  ✓ Sorting by distance                                     │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

### Multi-Field Pattern (Best Practice)

```json
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "english",
        "fields": {
          "exact": { "type": "keyword" },
          "autocomplete": { 
            "type": "text",
            "analyzer": "autocomplete_analyzer"
          }
        }
      },
      "brand": {
        "type": "keyword",
        "fields": {
          "search": { "type": "text" }
        }
      },
      "price": {
        "type": "scaled_float",
        "scaling_factor": 100
      }
    }
  }
}
```
