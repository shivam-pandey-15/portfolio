# 3.3 Document Modeling

The "Document" is the atomic unit of search. Getting the granularity and structure wrong is a one-way door that's expensive to fix.

---

## 1. What is a "Document"?

In Search, a document is **what you retrieve and rank as one unit**.

It is NOT necessarily:
- A database row
- A file on disk
- A product

**The Golden Rule**: Model based on what the **user sees on the result card**.

### Example: E-commerce Results

**What User Sees:**
```
┌────────────────────────────────────────┐
│ [IMAGE]  iPhone 15 Pro Max            │
│          ⭐⭐⭐⭐⭐ (4.8)  2,341 reviews │
│          From $999 - $1,499            │
│          6 colors available            │
└────────────────────────────────────────┘
```

**Question**: Is the document a Product or a SKU?

| If Document = Product | If Document = SKU |
|-----------------------|-------------------|
| 1 doc for iPhone 15 Pro Max | 6 docs (one per color) |
| Price shown as range | Price is exact |
| Colors aggregated | Each color separate |
| **Clean results** | **Cluttered results** |

---

## 2. Granularity Decisions

### Case Study: Fashion Retailer

**The Product:**
```
T-Shirt "Classic Cotton Crew"
├── Red, Size S
├── Red, Size M
├── Red, Size L
├── Blue, Size S
├── Blue, Size M
├── Blue, Size L
└── (6 SKUs total)
```

**Option A: Product-Level Document**
```json
{
  "product_id": "tshirt_001",
  "title": "Classic Cotton Crew",
  "colors": ["Red", "Blue"],
  "sizes": ["S", "M", "L"],
  "price_min": 29.99,
  "price_max": 34.99
}
```

**Problems with Product-Level:**
```json
// User searches: "Red T-shirt Size M"
// Query
{
  "bool": {
    "must": [
      { "match": { "title": "t-shirt" } },
      { "term": { "colors": "Red" } },
      { "term": { "sizes": "M" } }
    ]
  }
}

// This matches! But what if only Blue comes in M?
// We have the "Cross-Match Problem"
```

---

**Option B: SKU-Level Document**
```json
// 6 separate documents
{ "sku": "tshirt_001_red_s", "title": "Classic Cotton Crew", "color": "Red", "size": "S", "price": 29.99 }
{ "sku": "tshirt_001_red_m", "title": "Classic Cotton Crew", "color": "Red", "size": "M", "price": 29.99 }
{ "sku": "tshirt_001_red_l", "title": "Classic Cotton Crew", "color": "Red", "size": "L", "price": 34.99 }
{ "sku": "tshirt_001_blue_s", "title": "Classic Cotton Crew", "color": "Blue", "size": "S", "price": 29.99 }
{ "sku": "tshirt_001_blue_m", "title": "Classic Cotton Crew", "color": "Blue", "size": "M", "price": 29.99 }
{ "sku": "tshirt_001_blue_l", "title": "Classic Cotton Crew", "color": "Blue", "size": "L", "price": 34.99 }
```

**Problems with SKU-Level:**
```
User searches: "Cotton T-shirt"
Results:
1. Classic Cotton Crew (Red S)
2. Classic Cotton Crew (Red M)
3. Classic Cotton Crew (Red L)
4. Classic Cotton Crew (Blue S)
5. Classic Cotton Crew (Blue M)
... same shirt 6 times!
```

---

**Option C: SKU-Level with Result Collapsing**
```json
// Query with field collapsing
{
  "query": { "match": { "title": "cotton t-shirt" } },
  "collapse": {
    "field": "product_id",
    "inner_hits": {
      "name": "variants",
      "size": 5
    }
  }
}

// Result structure
{
  "hits": [
    {
      "product_id": "tshirt_001",
      "title": "Classic Cotton Crew",
      "color": "Red",     // Best matching variant shown
      "size": "M",
      "inner_hits": {     // Other variants available
        "variants": [
          { "color": "Red", "size": "S" },
          { "color": "Blue", "size": "M" },
          ...
        ]
      }
    }
  ]
}
```

**Performance Cost of Collapsing:**
| Approach | Query Time (100K products) |
|----------|---------------------------|
| No collapse | 15ms |
| Collapse | 35ms (+133%) |
| Collapse + inner_hits | 55ms (+267%) |

---

## 3. Modeling Relationships

### A. Flat Modeling (The Default)

**Structure:**
```json
{
  "product_id": "laptop_001",
  "title": "MacBook Pro 16",
  "brand": "Apple",                    // Flattened from Brand table
  "category": "Laptops",               // Flattened from Category table
  "category_path": ["Electronics", "Computers", "Laptops"],
  "colors": ["Space Gray", "Silver"],  // Array of values
  "specs_ram": "32GB",                 // Flattened specs
  "specs_storage": "1TB"
}
```

**When It Works:**
- 90% of use cases
- Arrays are treated as "any match" (not "all match")
- Fast queries, simple updates

**When It Fails: The Cross-Match Problem**

```json
// Document
{
  "title": "Running Shoes",
  "variants": {
    "colors": ["Red", "Blue"],
    "sizes": [8, 9, 10]
  }
}

// Reality: Red only comes in Size 8, Blue comes in 9 and 10

// User query: "Red Running Shoes Size 10"
// Result: MATCHES (incorrectly!)
// Because document has "Red" AND has "Size 10"
// But no Red Size 10 actually exists
```

---

### B. Nested Objects (Correct Matching)

**Structure:**
```json
{
  "title": "Running Shoes",
  "variants": [
    { "color": "Red", "size": 8, "stock": 15 },
    { "color": "Blue", "size": 9, "stock": 23 },
    { "color": "Blue", "size": 10, "stock": 8 }
  ]
}
```

**Mapping:**
```json
{
  "mappings": {
    "properties": {
      "variants": {
        "type": "nested"
      }
    }
  }
}
```

**Query:**
```json
{
  "query": {
    "nested": {
      "path": "variants",
      "query": {
        "bool": {
          "must": [
            { "term": { "variants.color": "Red" } },
            { "term": { "variants.size": 10 } }
          ]
        }
      }
    }
  }
}

// Result: NO MATCH (correct!)
// Because no single nested object has both Red AND Size 10
```

**The Hidden Cost:**
```
Lucene internal representation:

Parent Doc: { "title": "Running Shoes" }       [DocID 1]
Nested Doc: { "color": "Red", "size": 8 }      [DocID 2] (hidden)
Nested Doc: { "color": "Blue", "size": 9 }     [DocID 3] (hidden)
Nested Doc: { "color": "Blue", "size": 10 }    [DocID 4] (hidden)

1 Document = 4 Lucene Documents
```

**Update Amplification:**
```python
# Update: Change product title

# Without nested: Update 1 doc
# With nested: Update 1 parent + 3 nested = 4 docs

# Real example:
# Product with 100 variants
# Title update = 101 document updates
# 100 title updates/day = 10,100 writes/day (not 100)
```

---

### C. Parent-Child (Join at Query Time)

**Structure:**
```json
// Parent document
{
  "doc_type": "product",
  "product_id": "laptop_001",
  "title": "MacBook Pro",
  "brand": "Apple"
}

// Child documents (separate)
{
  "doc_type": "variant",
  "parent_id": "laptop_001",
  "color": "Space Gray",
  "price": 2499,
  "stock": 150
}
{
  "doc_type": "variant", 
  "parent_id": "laptop_001",
  "color": "Silver",
  "price": 2499,
  "stock": 89
}
```

**Mapping:**
```json
{
  "mappings": {
    "properties": {
      "relation": {
        "type": "join",
        "relations": {
          "product": "variant"
        }
      }
    }
  }
}
```

**Query: Find products with Silver variant in stock**
```json
{
  "query": {
    "has_child": {
      "type": "variant",
      "query": {
        "bool": {
          "must": [
            { "term": { "color": "Silver" } },
            { "range": { "stock": { "gt": 0 } } }
          ]
        }
      }
    }
  }
}
```

**Performance Comparison:**

| Operation | Flat | Nested | Parent-Child |
|-----------|------|--------|--------------|
| Query (100K docs) | 15ms | 20ms | **150ms** |
| Update parent | 5ms | 5ms | 5ms |
| Update child | 5ms | 50ms (all children) | **5ms** |
| Memory overhead | Low | Medium | **High** (global ordinals) |

**When to Use Parent-Child:**
- Inventory updates (100s/second per product)
- Price updates (real-time)
- Stock levels
- Content (title, description) updates are rare

---

## 4. The Denormalization Tax

**SQL Storage: 100MB**
```sql
SELECT * FROM products;              -- 10 MB
SELECT * FROM brands;                -- 1 MB  
SELECT * FROM categories;            -- 1 MB
SELECT * FROM product_attributes;    -- 88 MB
```

**Search Index Storage: 500MB**

Why 5x larger?
1. **Inverted Index**: Term → DocIDs mapping
2. **Doc Values**: DocID → Value for sorting/aggregation
3. **Stored Fields**: Original JSON for retrieval
4. **Norms**: Field length normalization for scoring
5. **Replication**: Usually 1 replica = 2x

**Storage Breakdown:**
```
100MB raw data
├── Inverted Index    80MB
├── Doc Values        40MB
├── Stored Fields    100MB
├── Positions/Offsets 60MB
├── Miscellaneous     20MB
└── Replica          300MB
────────────────────────────
Total:               ~600MB (6x raw)
```

---

## 5. Practical Decision Framework

```
┌─────────────────────────────────────────────────────────────┐
│                    GRANULARITY DECISION                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Q1: Do results show multiple variants of same item?         │
│      YES → SKU level + Collapsing                           │
│      NO  → Product level                                    │
│                                                              │
│  Q2: Do filters need to match variant-level attributes?      │
│      (e.g., "Red" + "Size M" must be same variant)          │
│      YES → Need Nested or Parent-Child                      │
│      NO  → Flat arrays are fine                             │
│                                                              │
│  Q3: How often do variant attributes change?                │
│      Price/Stock > 10x/day → Parent-Child                   │
│      Price/Stock < 1x/day  → Nested                         │
│                                                              │
│  Q4: How many variants per product?                         │
│      < 10   → Nested is fine                                │
│      > 100  → Consider Parent-Child or Sidecar Index        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```
