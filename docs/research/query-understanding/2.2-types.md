# Research: 2.2 Types of Queries

## The Classification Problem
Not all queries are created equal. Understanding query types helps you optimize for the right thing.

---

## Query Classification in Production

### Why It Matters
| Query Type | Optimization Goal | Success Metric |
|------------|-------------------|----------------|
| Navigational | Get them there fast | Position 1 accuracy |
| Informational | Answer the question | Dwell time, no reformulation |
| Transactional | Convert them | Conversion rate |
| Local | Connect with business | Directions requested |

### Real Distribution (Google Estimates)
| Type | % of Queries | Examples |
|------|--------------|----------|
| Navigational | 10-15% | "facebook", "gmail" |
| Informational | 50-60% | "how to", "what is" |
| Transactional | 20-30% | "buy", "download" |
| Local | 10-15% | "near me", location names |

---

## By User Intent (Deep Dive)

### 1. Navigational Queries
**User knows exactly where they want to go.**

#### Examples by Platform
| Platform | Query | Expected Result | If Wrong |
|----------|-------|-----------------|----------|
| Google | "facebook login" | Facebook login page | User goes to competitor |
| E-commerce | "my orders" | Order history | User contacts support |
| Enterprise | "company wiki" | Internal wiki | Lost productivity |

#### Characteristics
- Usually branded or site-specific
- Success = single correct result at #1
- Failure = catastrophic (user leaves immediately)
- Often typed instead of using bookmarks

#### Implementation
```python
NAVIGATIONAL_SIGNALS = {
    "high_confidence": [
        r"^(\w+)\s+(login|sign in|signin)$",
        r"^(go to |open )?\w+\.com$",
        r"^my\s+(orders|account|cart|wishlist)$"
    ],
    "medium_confidence": [
        r"^[A-Z][a-z]+$",  # Proper noun (brand)
        r"^(\w+)\s+(app|website|site)$"
    ]
}

def is_navigational(query: str) -> float:
    for pattern in NAVIGATIONAL_SIGNALS["high_confidence"]:
        if re.match(pattern, query, re.IGNORECASE):
            return 0.95
    for pattern in NAVIGATIONAL_SIGNALS["medium_confidence"]:
        if re.match(pattern, query):
            return 0.70
    return 0.10
```

#### Real Data: Top Navigational Queries by Volume
| Rank | Query | Monthly Searches | Intent |
|------|-------|------------------|--------|
| 1 | facebook | 500M+ | Go to Facebook |
| 2 | youtube | 400M+ | Go to YouTube |
| 3 | amazon | 300M+ | Go to Amazon |
| 4 | gmail | 250M+ | Go to Gmail |
| 5 | google | 200M+ | Go to Google (from Bing?) |

---

### 2. Informational Queries
**User wants to learn something.**

#### Sub-Types
| Sub-type | Pattern | Example | Expected Result |
|----------|---------|---------|-----------------|
| How-to | "how to X" | "how to tie a tie" | Tutorial, video |
| Definition | "what is X" | "what is blockchain" | Explanation |
| Factual | "who/when/where" | "who is CEO of Apple" | Direct answer |
| Comparison | "X vs Y" | "iPhone vs Samsung" | Comparison article |
| Research | Open-ended | "best practices for X" | Multiple sources |

#### Featured Snippets Strategy
```python
def should_show_featured_snippet(query: str) -> bool:
    """
    Determine if query deserves a direct answer box.
    """
    FEATURED_PATTERNS = [
        r"^what is\s+",
        r"^who is\s+",
        r"^when (did|was|is)\s+",
        r"^how (to|do|does|many|much)\s+",
        r"^why (do|does|is|are)\s+",
        r"\s+definition$",
        r"\s+meaning$"
    ]
    
    for pattern in FEATURED_PATTERNS:
        if re.search(pattern, query, re.IGNORECASE):
            return True
    return False
```

#### Real Data: Informational Query Patterns
| Pattern | Query Volume | Answer Type |
|---------|--------------|-------------|
| "how to X" | 15% of all queries | Step-by-step, video |
| "what is X" | 5% | Definition, wiki |
| "X vs Y" | 3% | Comparison table |
| "best X" | 8% | Listicle, reviews |
| "X near me" + "hours" | 2% | Business info |

---

### 3. Transactional Queries
**User wants to DO something (buy, download, sign up).**

#### Transaction Types
| Type | Signal Words | Conversion Goal |
|------|--------------|-----------------|
| Purchase | "buy", "order", "shop" | Add to cart |
| Download | "download", "install" | App install |
| Subscribe | "sign up", "subscribe" | Account creation |
| Book | "book", "reserve" | Reservation |
| Compare to Buy | "price", "deal", "discount" | Price-driven conversion |

#### E-commerce Transaction Signals
```python
TRANSACTIONAL_SIGNALS = {
    "explicit": [
        "buy", "purchase", "order", "shop",
        "price", "cheap", "discount", "deal",
        "free shipping", "coupon", "promo"
    ],
    "implicit": [
        "size", "color", "brand",  # Attribute = ready to buy
        "in stock", "available",
        "delivery", "shipping"
    ],
    "high_intent_patterns": [
        r"\d+\s*(gb|inch|mm)",  # Specific specs
        r"(mens?|womens?|kids?)\s+",  # Gender/age filter
        r"under\s+\$?\d+",  # Price constraint
        r"(best|top)\s+\d+",  # Comparison shopping
    ]
}

def transaction_intent_score(query: str) -> float:
    score = 0.0
    
    for word in TRANSACTIONAL_SIGNALS["explicit"]:
        if word in query.lower():
            score += 0.3
    
    for word in TRANSACTIONAL_SIGNALS["implicit"]:
        if word in query.lower():
            score += 0.15
    
    for pattern in TRANSACTIONAL_SIGNALS["high_intent_patterns"]:
        if re.search(pattern, query, re.IGNORECASE):
            score += 0.2
    
    return min(score, 1.0)
```

#### Case Study: Amazon Query Intent Classification
| Query | Detected Intent | Business Response |
|-------|-----------------|-------------------|
| "laptop" | Browse | Show categories, top brands |
| "gaming laptop" | Research | Show comparisons, reviews |
| "ASUS ROG 16GB" | High intent | Show product, price, delivery |
| "ASUS ROG coupon" | Very high intent | Show deals, Prime badge |

---

### 4. Local Queries
**User wants something nearby.**

#### Local Signals
| Signal | Example | Detection |
|--------|---------|-----------|
| Explicit location | "pizza in brooklyn" | NER (location entity) |
| "Near me" | "coffee near me" | Keyword match |
| Implicit local | "pizza" (mobile, 6pm) | Context inference |
| Business + action | "target hours" | Business name + local action |

#### Local Pack Ranking Factors
```python
LOCAL_RANKING_FACTORS = {
    "distance": 0.25,        # Proximity to user
    "relevance": 0.30,       # Match to query
    "prominence": 0.20,      # Reviews, ratings, links
    "recency": 0.10,         # Recent reviews, updates
    "engagement": 0.15       # Clicks, calls, directions
}

def score_local_result(business, query, user_location):
    score = 0.0
    
    # Distance (closer = better)
    distance = haversine(business.location, user_location)
    score += (1 - min(distance / 50, 1)) * LOCAL_RANKING_FACTORS["distance"]
    
    # Relevance
    relevance = text_match_score(query, business.name + business.category)
    score += relevance * LOCAL_RANKING_FACTORS["relevance"]
    
    # Prominence
    score += business.rating_score * LOCAL_RANKING_FACTORS["prominence"]
    
    return score
```

---

## By Query Structure (Analytics)

### Query Length Distribution
| Length | % of Queries | Characteristics |
|--------|--------------|-----------------|
| 1 word | 20-25% | Highly ambiguous, navigational or exploratory |
| 2 words | 25-30% | Category + modifier, brand + product |
| 3 words | 20-25% | More specific, often transactional |
| 4 words | 10-15% | Filtered intent, comparison |
| 5+ words | 10-15% | Very specific or natural language |

### Complexity vs. Conversion
| Query Complexity | CTR | Conversion | Reason |
|------------------|-----|------------|--------|
| 1 word | 25% | 1.5% | Exploratory, low intent |
| 2-3 words | 35% | 3.5% | Clearer intent |
| 4-5 words | 40% | 5.5% | High intent, specific |
| 6+ words | 32% | 4.0% | Often natural language, harder to serve |

---

## By Query Frequency (Operations)

### Head Queries: The Special Cases
```python
HEAD_QUERIES = {
    "iphone": {
        "daily_volume": 5_000_000,
        "handling": "manual_curation",
        "cache_ttl": 300,
        "ab_test": True,
        "dedicated_team": True
    },
    "shoes": {
        "daily_volume": 2_000_000,
        "handling": "category_boost",
        "cache_ttl": 120,
        "ab_test": True
    }
}
```

### Tail Queries: The Long Tail Engine
```python
def handle_tail_query(query: str) -> SearchResults:
    """
    For queries with <100 daily searches.
    Must be fully automated.
    """
    # 1. Semantic understanding (embeddings)
    query_embedding = embed(query)
    
    # 2. Entity extraction
    entities = extract_entities(query)
    
    # 3. Hybrid search
    results = hybrid_search(
        text_query=query,
        vector_query=query_embedding,
        filters=entities_to_filters(entities)
    )
    
    # 4. If low results, relax constraints
    if len(results) < 10:
        results = search_with_relaxation(query, entities)
    
    return results
```

---

## Query Classification System (Production)

### Multi-Label Classification
```python
class QueryClassifier:
    def __init__(self):
        self.intent_model = load_model("intent_classifier_v3")
        self.entity_extractor = load_model("ner_v2")
        
    def classify(self, query: str, context: UserContext) -> QueryClassification:
        # Extract features
        features = {
            "query_text": query,
            "query_length": len(query.split()),
            "has_question_word": self._has_question_word(query),
            "has_transaction_word": self._has_transaction_word(query),
            "has_location": self._has_location(query),
            "user_is_logged_in": context.is_logged_in,
            "device": context.device,
            "hour_of_day": context.hour,
            "previous_query": context.previous_query
        }
        
        # Multi-label classification
        intent_probs = self.intent_model.predict(features)
        
        return QueryClassification(
            navigational=intent_probs["navigational"],
            informational=intent_probs["informational"],
            transactional=intent_probs["transactional"],
            local=intent_probs["local"],
            entities=self.entity_extractor.extract(query)
        )
```

### Real Production Metrics
| Model Version | Accuracy | Latency (P50) | Latency (P99) |
|---------------|----------|---------------|---------------|
| Rules-only | 72% | 1ms | 5ms |
| Logistic regression | 81% | 3ms | 10ms |
| XGBoost | 85% | 8ms | 25ms |
| BERT-tiny | 89% | 15ms | 50ms |
| Distilled BERT | 91% | 12ms | 40ms |

---

## Key Takeaways

1. **Intent classification is the first step** in understanding a query
2. **Head queries are different from tail** — different optimization needed
3. **Short queries are the hardest** — maximum ambiguity
4. **Natural language is growing** — need semantic understanding
5. **Domain matters** — e-commerce, content, enterprise have different patterns
6. **Multi-label classification works best** — queries can have mixed intent
7. **Context boosts accuracy significantly** — device, time, history
8. **Latency matters** — classification must complete in <20ms
